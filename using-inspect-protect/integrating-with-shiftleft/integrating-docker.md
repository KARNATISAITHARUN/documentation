# Integrating with Docker

Many microservices are built and deployed today as Docker containers. You can integrate ShiftLeft Inspect and ShiftLeft Protect with your Docker image builds and deployments.

There are two ways to integrate ShiftLeft with Docker:

* **[Container Only](#container-only-integration)**: Both ShiftLeft Inspect and ShiftLeft Protect execute from within the container during the application container run.

* **[Host Plus Container](#host-plus-container-integration)**: ShiftLeft Inspect analyzes the code on the host prior to the application container run. Then during the container run, ShiftLeft Protect is only run for each execution.

## Definitions

- **Target Application**: The JAR artifact of the target application built using either a custom build script or a CI such as Jenkins or Travis. This artifact is identified here as `app.jar`
 
- **Target Image**: The container image that is run in production containing the target JAR. ShiftLeft Inspect and ShiftLeft Protect are configured into this Docker image. 

- **Dockerfile**: The Dockerfile used to build the target image. In order to provision ShiftLeft Inspect and ShiftLeft Protect in the target image, the Dockerfile is customized prior to using the `docker build` command.

## Container Only Integration

In this integration, both ShiftLeft Inspect and ShiftLeft Protect execute from within the container during application container run. 

During the container build, the target image needs to be bundled with all ShiftLeft dependencies. To do so, fetch the `sl` binary and copy the ShiftLeft configuration (`config.json`) generated by [authenticating](../using-cli/authenticating.md). There are two methods to achieve the container-only solution: [separating the code analysis from securing the application](#separating-analysis-and-execution-within-the-container), and [integrating the analysis as part of securing the application](#integrating-analysis-and-execution-within-the-container). 

### Separating Analysis and Execution within the Container

In this method, ShiftLeft Inspect conducts code analysis and then ShiftLeft Protect executes your application. For example, a typical Dockerfile that performs these steps for a target application is 

```Dockerfile
FROM alpine
WORKDIR /usr/src/app

RUN apk --update --no-cache add curl openjdk8

COPY app.jar /user/src/app/app.jar

# Install ShiftLeft CLI
RUN curl https://cdn.shiftleft.io/download/sl-latest-linux-x64.tar.gz | tar xvz -C /usr/local/bin
ENV SHIFTLEFT_ORG_ID=...
ENV SHIFTLEFT_ACCESS_TOKEN=...

# Run ShiftLeft code analysis
RUN sl analyze --wait --app MyApplication app.jar

# Run target app with ShiftLeft Microagent
CMD sl run -- java -jar app.jar
```

### Integrating Analysis and Execution within the Container

This method avoids the separate analysis and execution steps, by having ShiftLeft Protect launch ShiftLeft Inspect and then execute the application. This method also allows you to specify your application name such as _MyApplication_ using the `--app` option. For example, the Dockerfile

```Dockerfile
FROM alpine
WORKDIR /usr/src/app

RUN apk --update --no-cache add curl openjdk8

COPY app.jar /user/src/app/app.jar

# Install ShiftLeft CLI
RUN curl https://cdn.shiftleft.io/download/sl-latest-linux-x64.tar.gz | tar xvz -C /usr/local/bin
ENV SHIFTLEFT_ORG_ID=...
ENV SHIFTLEFT_ACCESS_TOKEN=...

# Do ShiftLeft code analysis and run target app with ShiftLeft Microagent
CMD sl run --app MyApplication --analyze app.jar -- java -jar app.jar
``` 

## Host Plus Container Integration

ShiftLeft Inspect can perform code analysis on the host immediately after the target JAR is built by your CI, and before the Docker target image is built. For example, if you are using Maven as your build system and Jenkins as the CI, code analysis can be added as a post-build step using the [Exec Maven Plugin](https://www.mojohaus.org/exec-maven-plugin/). For example, an excerpt from the `pom.xml` file for the Maven project is 

```xml
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>exec-maven-plugin</artifactId>
    <version>1.6.0</version>
    <executions>
        <execution>
            <id>shiftleft-analyze</id>
            <phase>package</phase>
            <configuration>
                <executable>sl</executable>
                <workingDirectory></workingDirectory>
                <arguments>
                    <argument>analyze</argument>
                </arguments>
                <arguments>
                    <argument>--wait</argument>
                </arguments>
            </configuration>
            <goals>
                <goal>exec</goal>
            </goals>
        </execution>
    </executions>
</plugin>

```

If you are using another build system, remember to analyze on the host beforehand using `sl analyze --wait`, so that the application configuration  `shifteft.json` file is generated in the same directory. Note that this file is distinct from the `config.json` file, which is generated after a successful ShiftLeft authentication. In the following example of building the target image, the `shiftleft.json` file needs to be copied into the container image so that it can be used when the application is run

```Dockerfile
FROM alpine
WORKDIR /usr/src/app

RUN apk --update --no-cache add curl openjdk8

COPY app.jar /user/src/app/app.jar

# Install ShiftLeft CLI
RUN curl https://cdn.shiftleft.io/download/sl-latest-linux-x64.tar.gz | tar xvz -C /usr/local/bin

# Copy ShiftLeft Application Configuration app directory
COPY shiftleft.json /usr/src/app/shiftleft.json

# Run target app with ShiftLeft Microagent
CMD sl run -- java -jar app.jar
```
