# Java Vulnerable Lab

This tutorial is based on the popular Java project Java Vulnerable Lab, a benchmarking application for
vulnerability discovery tools. The tutorial illustrates the core features of ShiftLeft, and shows how ShiftLeft Ocular tooling can be adapted and extended to:

This tutorial walks you through the core features of the ShiftLeft
Command Line Tools. The tutorial demonstrates how the tooling can be

## Prerequisite

Install ShiftLeft Ocular into your local directory `$shiftleft`. Refer to 
[Installing ShiftLeft Ocular](../installation.md) for more information.

## Running the Java Vulnerable Lab Sample Application

This tutorial is based on the sample application [Java Vulnerable Lab](https://github.com/CSPF-Founder/JavaVulnerableLab). The project's WAR file is also included in the ShiftLeft Ocular distribution for your convenience.

Java Vulnerable Lab a Java web application using JSP and
servlets. It comes with different sample vulnerabilities, including
typical injection vulnerabilities like sql injection. 

Focusing on an SQL injection vulnerability in the `EmailCheck.java`, this
controller also consumes POST requests. The GET
request that ends up in a SQL query is of particular interest.

```
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("application/json");
    PrintWriter out = response.getWriter();
    try {
           Connection con=new DBConnect().connect(getServletContext().getRealPath("/WEB-INF/config.properties"));
           String email=request.getParameter("email").trim();
           JSONObject json=new JSONObject();
            if(con!=null && !con.isClosed())
            {
                ResultSet rs=null;
                Statement stmt = con.createStatement();  
                rs=stmt.executeQuery("select * from users where email='"+email+"'");
            [...]
}

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    processRequest(request, response);
}
```

The variable `request` is of type
`HttpServletRequest` and is part of the `doGet` signature. The object is passed to `processRequest`, where the parameter
`email` is read as a string. The variable is concatenated to
the SQL query without prior checks. This leads to an SQL injection. This vulnerability is identified using
ShiftLeft Ocular.

## Generating CPGs and Security Profiles


Please begin by downloading thee WAR file from GitHub. The code
property graph and security profile can then be created as follows:

```
cd $shiftleft
./java2cpg.sh subjects/JavaVulnerableLab.war -o cpg.bin.zip
```

This command creates a file named `cpg.bin.zip` containing the code
property graph and security profile in a binary format. The security profile summarizes potentially vulnerable flows. The security profileis generated by evaluating the security policy in ~/.shiftleft/policy/
against the CPG.

(For an additional output format, refer to the java2cpg documentation.)

## Generating an Initial Scan Report

ShiftLeft Ocular lets you query CPGs
and Security profiles, both interactively and
non-interactively. An example of non-interactive querying is the script in `scripts/report.sc`:

```
@main def exec(spFilename: String, outFilename: String) = {
  loadSp(spFilename)
  sp.findings.sortedByScore.l |> outFilename
}
```

This script loads the Security Profile at `spFilename`, and evaluates
the expression `sp.findings.sortedByScore.l` to obtain a list of
findings sorted by score. The list is piped to the file `outFilename`
via the `|>` operator.

You can run this script as
```
./ocular.sh --script scripts/report.sc --params spFilename=javavulnerablelab.sp,outFilename=report.txt
```

As a result, the text file `report.txt` is generated, which contains
all findings in a human-readable format. Take a look at one of 
the findings to get an idea of the type of information the report
contains

```
Title: http-to-sql
Score: 9.0
Categories: [a1-injection]
Flow ids: [1715]
Description: Attacker controlled data is used in a SQL query without undergoing escaping or validation. This could allow an attacker to read sensitive data from the database or modify its content.See http://cwe.mitre.org/data/definitions/89.html
-------------------------------------
Flow 0:
IO Tags: Set(http) -> Set(sql)
Data Tags: Set(DATA_TYPE: pii, DATA_TYPE: contact, DATA_LANGUAGE: SQL)
routes: 
trigger methods:
org.cysecurity.cspf.jvl.controller.EmailCheck.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
org.cysecurity.cspf.jvl.controller.EmailCheck.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)

Primary flow:
 ____________________________________________________________________________________________________________________________________________________________________________________________________________________
 | param     | type                                 | method        | signature                                                                                                                                      |
 |===================================================================================================================================================================================================================|
 | request(1)| javax.servlet.http.HttpServletRequest| doGet         | org.cysecurity.cspf.jvl.controller.EmailCheck.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)         |
 | request(1)| javax.servlet.http.HttpServletRequest| processRequest| org.cysecurity.cspf.jvl.controller.EmailCheck.processRequest:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)|
 | this(0)   | javax.servlet.http.HttpServletRequest| getParameter  | javax.servlet.http.HttpServletRequest.getParameter:java.lang.String(java.lang.String)                                                          |
 | return(-1)| java.lang.String                     | getParameter  | javax.servlet.http.HttpServletRequest.getParameter:java.lang.String(java.lang.String)                                                          |
 | this(0)   | java.lang.String                     | trim          | java.lang.String.trim:java.lang.String()                                                                                                       |
 | return(-1)| java.lang.String                     | trim          | java.lang.String.trim:java.lang.String()                                                                                                       |
 | email     | java.lang.String                     | processRequest| org.cysecurity.cspf.jvl.controller.EmailCheck.processRequest:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)|
 | param0(1) | java.lang.String                     | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | return(-1)| java.lang.StringBuilder              | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | this(0)   | java.lang.StringBuilder              | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | return(-1)| java.lang.StringBuilder              | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | this(0)   | java.lang.StringBuilder              | toString      | java.lang.StringBuilder.toString:java.lang.String()                                                                                            |
 | return(-1)| java.lang.String                     | toString      | java.lang.StringBuilder.toString:java.lang.String()                                                                                            |
 | param0(1) | java.lang.String                     | executeQuery  | java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)                                                       |
```

Along with other findings, notice an SQL injection vulnerability
triggerable via HTTP with a score of 9.0. Findings are scored in order
to allow for filtering. Findings also include a human-readable
description that further characterizes the potential vulnerability, as
well as the information flows associated with the vulnerability.

In this example, a single information flow is associated with the
vulnerability. ShiftLeft Ocular identifies that the parameter
`request` of the method `doGet` is attacker-controlled with high
probability, since it is an HTTP request parameter. Tracking the flow of
`request`, the variable is passed into the method `processRequest`
where it is Base64-decoded and used in the initialization of a
`ByteArrayInputStream`. This input stream is itself used to initialize
an `ObjectInputStream`. Lastly, the `readObject` method is invoked on the
tainted input stream, resulting in the deserialization of
attacker-controlled data. The flow description additionally provides
HTTP input routes when possible (`/admin/login` in this case), and
externally triggerable methods to invoke the vulnerable flow
(`doPostLogin` in this example).

## Interactively Exploring and Filtering Security Profiles

Security Profiles can be explored interactively with ShiftLeft Ocular, using a
domain specific language. Start ShiftLeft Ocular by

```
 ./ocular.sh

 Welcome to the cpg console :)
 Commands:
 helpMsg                         // prints this help dialog
 status                          // prints the current status
 loadCpg("path/to/file.[xml|gryo|bin.zip]") // loads cpg (format inferred from suffix)
 loadSp("path/to/file.[sp]")                // loads sp
 ...

 Ocular status:
 No CPG currently loaded.
 CPG can be loaded via a `loadCpg` command. See `help`.
 Welcome to the Ocular - what would you like to query today? ;)
 ocular>
```
 
As demonstrated in the non-interactive script report.sc, load
the Security Profile "javavulnerablelab.sp" by issuing the command

```
loadSp("javavulnerablelab.sp")
```

This creates an object named `sp` that provides access to the Security
Profile. ShiftLeft Ocular offers tab-completion to facilitate learning of the
domain specific query language. For example, enter

```
 sp.findings.<TAB>
 !=             category       equals         getClass       isInstanceOf   raw            scoreAtMost    spTestsFlows   |>
 ==             dedup          filter         hashCode       l              score          size           title
 asInstanceOf   description    flatMap        ioFlows        map            scoreAtLeast   sortedByScore  toString
```

to obtain a list of possible operations that can be executed on
findings. In particular, findings support the `scoreAtLeast` method,
which allows findings to be filtered such that only findings scored
above or equal to a threshold are returned. For example

```
sp.findings.scoreAtLeast(8).l.size
```

returns only findings with a score of at least 8. Note that the
query language is lazily evaluated, that is,
`sp.findings.scoreAtLeast(8)` only yields in an expression, and it is
only evaluated as it is converted to a list via the `l` directive (a
shorthand for "toList").

All string properties support regular expressions. For example, you
can obtain all findings related to serialization by

```
sp.findings.title(".*serialize.*").l
```

All lists support the functional combinators of the Scala language.
Moreover, the functional combinators `filter`, `map`, and
`flatMap` are provided directly for expression of the DSL. For example, instead of
using the built-in method `scoreAtLeast`, the same effect can be
achieved via a filter operation 

```
sp.findings.filter(_.score >= 8).size
```

This allows more complex filtering rules to be expressed via lambdas.
For example

```
sp.findings.filter(x =>  x.score >=8 && x.categories.contains("a1-injection")).l
```

returns only the findings with a score greater or equal to 8, where
the finding's categories includes "a1-injection".

## Uncovering Attack Surface with the CPG

The CPG contains information about the processed code
on different levels of abstraction: from dependencies, to type
hierarchies, control flow, data flow, and instruction-level
information. Like the Security Profile, the CPG can be queried interactively using ShiftLeft Ocular or through non-interactive scripts. 

The CPG is loaded via the `loadCpg` command:

```
loadCpg("cpg.bin.zip")
```

This creates the object `cpg`, which provides access to the CPG. Exploring the program dependencies

```
cpg.dependency.name.l
```

This provides a complete list of all dependency names. We support functional
combinators. For example, to output (name, version) pairs, we can use
the following expression: 

```
cpg.dependency.map(x => (x.name, x.version)).l
```
which yields

```
cpg.dependency.map(x => (x.name, x.version)).l 
res2: List[(String, String)] = List(
  ("junit", "3.8.1"),
  ("json", "20090211"),
  ("servlet-api", "2.3"),
  ("jstl", "1.2"),
  ("hibernate-core", "4.0.1.Final"),
  ("mysql-connector-java", "5.1.26"),
  ("hibernate-core", "4.0.1.Final"),
  ("commons-collections", "3.2.1"),
  ("hibernate-commons-annotations", "4.0.1.Final"),
  ("xml-apis", "1.0.b2"),
  ("jstl", "1.2"),
  ("dom4j", "1.6.1"),
  ("jboss-logging", "3.1.0.CR2"),
  ("jboss-transaction-api_1.1_spec", "1.0.0.Final"),
  ("antlr", "2.7.7"),
  ("hibernate-jpa", "2.0-api-1.0.1.Final"),
  ("javassist", "3.15.0-GA"),
  ("json", "20090211")
)

```

It is also possible to process CPG subgraphs using external programs by
exporting the subgraphs to JSON. For example

```
cpg.dependency.toJson |> "/tmp/dependencies.json"
```

dumps complete dependency information into the file "/tmp/dependencies.json" is
JSON format. Fields of the CPG can be queried using regular
expressions. For example, to determine whether an application uses the
servlet api, a quick query is

```
cpg.dependency.name(".*servlet.*").l.nonEmpty 
res9: Boolean = true
```

The `servlet-api` indicates that methods with
a `HttpServletRequest` type as parameter are of interest. Finding these methods can be done with the
query

```
cpg.method.parameter.evalType(".*HttpServletRequest.*").method.fullName.p 
[...]
org.cysecurity.cspf.jvl.controller.EmailCheck.processRequest:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
org.cysecurity.cspf.jvl.controller.EmailCheck.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
org.cysecurity.cspf.jvl.controller.EmailCheck.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
[..]
```

The first source

```
val source = cpg.method.fullName(".*EmailCheck.*").parameter 
```

This query defines every parameter of methods which
signature names matching `.*EmailCheck.*`, as source. The next step is
to define the sinks. Assuming no knowledge of the target, look for methods that contain `execute` in
their name by

```
cpg.method.name("execute.*").fullName.p 
java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)
java.sql.Statement.executeUpdate:int(java.lang.String)
java.sql.PreparedStatement.executeUpdate:int()
```

Three methods are identified, with two of them known to be a traditional
sink SQL injection sink. Marking the parameter as sink

```
ocular> val sink = cpg.method.name(".*execute.*").parameter 
```

The next step is to find a flow between the sink and source

```
ocular> sink.reachableBy(source).flows.p 
[...]
request 	 80 	 doGet 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
request 	 81 	 doGet 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
request 	 37 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
request 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 getParameter 	 javax/servlet/http/HttpServletRequest.java
$ret 	  	 getParameter 	 javax/servlet/http/HttpServletRequest.java
request.getParameter("email") 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r3 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r3 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 trim 	 java/lang/String.java
$ret 	  	 trim 	 java/lang/String.java
$r3.trim() 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
email 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
email 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param0 	  	 append 	 java/lang/StringBuilder.java
$ret 	  	 append 	 java/lang/StringBuilder.java
$r5.append(email) 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r6 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r6 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 append 	 java/lang/StringBuilder.java
$ret 	  	 append 	 java/lang/StringBuilder.java
$r6.append("\'") 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r7 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r7 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 toString 	 java/lang/StringBuilder.java
$ret 	  	 toString 	 java/lang/StringBuilder.java
$r7.toString() 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r8 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r8 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param0 	  	 executeQuery 	 java/sql/Statement.java
[...]
```


The flows can be examined manually or automatically. For example, to determine parameters controlled as a result of data flows 

```
sinks.reachableBy(sources).flows.l.flatMap(_.pathElems.last.parameters.l)
```

This query determines sinks reachable by sources and examines the
corresponding data flows. The last flow element is extracted from each
flow using the `pathElemens.last` directive, and the corresponding
parameter is retrieved. The result of the query can be stored in a
variable for further processing, which is useful when determining
a large number of data flows

```
val controlled = sinks.reachableBy(sources).flows.l.flatMap(_.pathElems.last.parameters.l)
```
Retrieve the parameter index ("order" and method full name) by

```
controlled.map(x => s"Controlling parameter ${x.order} of ${x.start.method.fullName.l.head}")
res14: List[String] = List(
  "Controlling parameter 1 of java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)",
  "Controlling parameter 1 of java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)",
  "Controlling parameter 1 of java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)"
)
```

## Using a Security Policy to Scan for Data-Flow Vulnerabilities

The CPG query language can be used to formulate vulnerability
patterns, and these queries can be used in a non-interactive script to
automatically scan for vulnerability patterns. For data-flow related
vulnerabilities, ShiftLeft Ocular provides a more concise
mechanism, the Security Policy. A Security Policy defines methods that
introduce data into the application, sensitive operations, and
data-flow that should be reported. For example, in
ShiftLeft's dynamic policy, find the following lines

```
// [~/.shiftleft/policy/dynamic/java/sql/Statement.policy:]
IO sql = METHOD -f "java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)" { PAR -i 1 "SINK" }
```

This states that the first parameter of the method `executeQuery` should be considered as a data sink of an SQL query.

```
EXPOSED http = SUPERTYPE -f "javax.servlet.http.HttpServlet" METHOD -n r"do(Get|Post|Delete|Put|Head|Options|Trace)" { PAR -t "javax.servlet.http.HttpServletRequest" "SOURCE" } 
```

This rule specifies that all parameters of the methods
`do(Get|Post|Delete|Put|Head|Options|Trace)` with the type
`javax.servlet.http.HttpServletRequest` are tagged as `http`.
Furthermore the class that implements these methods needs to derive
`javax.servlet.http.HttpServlet`.

Finally, specify that flows of `http` data into `sql`, without
any escaping, encrypting, encoding or hashing, are worth reporting
```
// ~/.shiftleft/policy/static/sqlinjection.policy:

CONCLUSION http-to-sql = FLOW IO (http) -> DATA (NOT encrypted AND NOT hashed AND NOT encoded AND NOT escaped) -> IO (sql)
WHEN CONCLUSION http-to-sql => EMIT {
  title: "SQL Injection",
  description: "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This could allow an attacker to read sensitive data from the database or modify its content.See http://cwe.mitre.org/data/definitions/89.html",
  category: "a1-injection",
  score: "9.0"
}
```

The Security Policy also allows data transformations and
checks to be specified in order to report flows of data, for data that 
does not undergo validation. For more information, refer to the [Security Policy Language](../../policies/spl.md) article.
